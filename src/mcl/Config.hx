package mcl;

import js.Syntax;
import js.lib.Object;
import haxe.crypto.Sha1;
import haxe.io.Path;

private class EventDispatcher<T> {
	public function new() {
		this._subscribers = new Array<T->Void>();
	}

	public function subscribe(callback:T->Void) {
		this._subscribers.push(callback);
	}

	public function dispatch(event:T) {
		if (this._subscribers.length == 0)
			return;
		for (subscriber in this._subscribers) {
			subscriber(event);
		}
	}

	private var _subscribers:Array<T->Void>;
}

typedef PreBuildEvent = {};
typedef PostBuildEvent = {success:Bool};

class ConfigEvents {
	// private var _subscribers:Map<String, Array<Function>>;
	public function new() {}

	public final onPreBuild = new EventDispatcher<PreBuildEvent>();
	public final onPostBuild = new EventDispatcher<PostBuildEvent>();
}

private class ConfigUtil {
	public static var getPackId:Void->String = function() {
		var packId = Sha1.encode(Sys.getCwd());
		return packId;
	};

	public static function lock<T:{}>(obj:T):T {
		Object.freeze(obj);
		for (field in Reflect.fields(obj)) {
			var value = Reflect.field(obj, field);
			if (value != null && Syntax.typeof(value) == 'object') {
				lock(value);
			}
		}
		return obj;
	}
}

@:keep
@:keepSub
class Config {
	public var debug:Bool = false;
	public var libDir:String = Path.join([Sys.programPath(), '..', '.mcblib']);
	public var events:ConfigEvents = new ConfigEvents();
	public var generatedDirName:String = 'zzz';
	public var internalId:String = ConfigUtil.getPackId();

	/**
	 *
	 * The name of the scoreboard that will be used to store the internal state of the mcb.
	 */
	public var internalScoreboardName:String;

	/**
	 *
	 * The Io instance that will be used to handle file writing, this is not compatible with the `io-thread-count` argument
	 */
	public var io:Null<Io> = null;

	/**
	 * 
	 * The message to put at the top of every file that is generated by mcb that supports comments.
	 *
	 */
	public var header:String = "#This file was generated by mcb\n";

	public var enableHeaderParameters:Bool = false;

	/**
	 * 
	 * The number of threads to use for file writing, this is not compatible with the `io` parameter or `io-thread-count` argument
	 * 
	 */
	public var ioThreadCount:Null<Int> = null;

	// public var autoCreateScoreboard:Bool = true;
	private function new() {
		this.internalScoreboardName = 'mcb.i.' + this.internalId;
	}

	public static function create(base:UserConfig):Config {
		ConfigUtil.lock(base); // make sure the user can't change the config after it's been created

		var c = new Config();
		if (base.debug != null)
			c.debug = base.debug;
		if (base.libDir != null)
			c.libDir = base.libDir;
		if (base.generatedDirName != null)
			c.generatedDirName = base.generatedDirName;
		if (base.internalId != null)
			c.internalId = base.internalId;
		if (base.internalScoreboardName != null)
			c.internalScoreboardName = base.internalScoreboardName;
		if (base.io != null && base.ioThreadCount == null)
			c.io = base.io;
		if (base.header != null)
			c.header = base.header;
		if (base.enableHeaderParameters != null)
			c.enableHeaderParameters = base.enableHeaderParameters;
		if (base.ioThreadCount != null && base.io != null)
			c.ioThreadCount = base.ioThreadCount;
		if (base.setup != null)
			base.setup(c);

		return c;
	}
}

@:keep
interface UserConfig {
	public var debug:Null<Bool>;
	public var libDir:Null<String>;
	public var generatedDirName:Null<String>;
	public var internalId:Null<String>;

	/**
	 *
	 * The name of the scoreboard that will be used to store the internal state of the mcb.
	 */
	public var internalScoreboardName:Null<String>;

	/**
	 *
	 * The Io instance that will be used to handle file writing, this is not compatible with the `io-thread-count` argument
	 */
	public var io:Null<Io>;

	/**
	 * 
	 * The message to put at the top of every file that is generated by mcb that supports comments.
	 *
	 */
	public var header:Null<String>;

	public var enableHeaderParameters:Null<Bool>;

	/**
	 * 
	 * The number of threads to use for file writing, this is not compatible with the `io` parameter or `io-thread-count` argument
	 * 
	 */
	public var ioThreadCount:Null<Int>;

	/**
	 * allows for binding of compiler events.
	 */
	public var setup:Null<Config->Void>;
}
